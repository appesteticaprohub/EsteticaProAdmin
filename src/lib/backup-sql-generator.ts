import type { BackupData, TableMetadata, ColumnInfo, RLSPolicy } from '@/types/backup'

export class BackupSQLGenerator {
  /**
   * Genera el script SQL completo del backup
   */
  static generate(backupData: BackupData): string {
    const sections: string[] = []

    // Header con metadata
    sections.push(this.generateHeader(backupData))

    // Extensiones
    if (backupData.extensions.length > 0) {
      sections.push(this.generateExtensions(backupData.extensions))
    }

    // Para cada tabla
    const tableNames = Object.keys(backupData.tables).sort()
    
    for (const tableName of tableNames) {
      const tableData = backupData.tables[tableName]
      
      // Estructura de la tabla
      if (tableData.structure && backupData.metadata.config.options.includeStructure) {
        sections.push(this.generateTableStructure(tableData.structure))
      }

      // Datos de la tabla
      if (tableData.data.length > 0 && backupData.metadata.config.options.includeData) {
        sections.push(this.generateTableData(tableName, tableData.data))
      }

      // Políticas RLS
      if (tableData.policies.length > 0 && backupData.metadata.config.options.includeRLS) {
        sections.push(this.generateRLSPolicies(tableData.policies))
      }
    }

    // Índices (después de insertar datos para mejor performance)
    if (backupData.metadata.config.options.includeIndexes) {
      for (const tableName of tableNames) {
        const tableData = backupData.tables[tableName]
        if (tableData.structure?.indexes.length > 0) {
          sections.push(this.generateIndexes(tableData.structure))
        }
      }
    }

    // Foreign keys (al final para evitar problemas de dependencias)
    if (backupData.metadata.config.options.includeStructure) {
      for (const tableName of tableNames) {
        const tableData = backupData.tables[tableName]
        if (tableData.structure?.foreignKeys.length > 0) {
          sections.push(this.generateForeignKeys(tableData.structure))
        }
      }
    }

    return sections.join('\n\n')
  }

  /**
   * Genera el header con información del backup
   */
  private static generateHeader(backupData: BackupData): string {
    const { metadata } = backupData
    return `-- =====================================================
-- ESTETICA PRO - DATABASE BACKUP
-- =====================================================
-- Generated at: ${metadata.generatedAt}
-- Generated by: ${metadata.generatedBy}
-- Version: ${metadata.version}
-- Backup type: ${metadata.config.type}
-- Format: ${metadata.config.format}
-- =====================================================
-- Configuration:
--   Include Structure: ${metadata.config.options.includeStructure}
--   Include Data: ${metadata.config.options.includeData}
--   Include RLS: ${metadata.config.options.includeRLS}
--   Include Triggers: ${metadata.config.options.includeTriggers}
--   Include Indexes: ${metadata.config.options.includeIndexes}
--   Include Extensions: ${metadata.config.options.includeExtensions}
${metadata.config.dateFrom ? `--   Date From: ${metadata.config.dateFrom}` : ''}
${metadata.config.dateTo ? `--   Date To: ${metadata.config.dateTo}` : ''}
-- =====================================================

BEGIN;

SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;`
  }

  /**
   * Genera statements para crear extensiones
   */
  private static generateExtensions(extensions: string[]): string {
    const statements = extensions.map(ext => 
      `CREATE EXTENSION IF NOT EXISTS "${ext}" WITH SCHEMA public;`
    )
    
    return `-- =====================================================
-- EXTENSIONS
-- =====================================================

${statements.join('\n')}`
  }

  /**
   * Genera el CREATE TABLE statement
   */
  private static generateTableStructure(metadata: TableMetadata): string {
    const { tableName, columns, primaryKeys } = metadata
    
    const columnDefs = columns.map(col => this.formatColumnDefinition(col))
    
    // Agregar PRIMARY KEY si existe
    if (primaryKeys.length > 0) {
      columnDefs.push(`PRIMARY KEY (${primaryKeys.map(k => `"${k}"`).join(', ')})`)
    }

    return `-- =====================================================
-- TABLE: ${tableName}
-- Rows: ${metadata.rowCount}
-- =====================================================

DROP TABLE IF EXISTS public."${tableName}" CASCADE;

CREATE TABLE public."${tableName}" (
    ${columnDefs.join(',\n    ')}
);`
  }

  /**
   * Formatea la definición de una columna
   */
  private static formatColumnDefinition(col: ColumnInfo): string {
    // Normalizar el tipo de dato
    const normalizedType = this.normalizeDataType(col.type)
    
    let def = `"${col.name}" ${normalizedType}`
    
    if (!col.nullable) {
      def += ' NOT NULL'
    }
    
    if (col.defaultValue) {
      def += ` DEFAULT ${col.defaultValue}`
    }
    
    return def
  }

  /**
   * Normaliza tipos de datos de PostgreSQL
   */
  private static normalizeDataType(type: string): string {
    // Si el tipo es "ARRAY", necesitamos convertirlo al formato correcto
    // PostgreSQL reporta "ARRAY" pero la sintaxis correcta es "tipo[]"
    
    // Casos especiales conocidos
    const typeMap: Record<string, string> = {
      'ARRAY': 'text[]', // Por defecto, pero esto debería detectarse mejor
      'character varying': 'varchar',
      'timestamp without time zone': 'timestamp',
      'timestamp with time zone': 'timestamptz',
      'time without time zone': 'time',
      'time with time zone': 'timetz'
    }
    
    // Convertir a minúsculas para comparación
    const lowerType = type.toLowerCase()
    
    // Buscar en el mapa
    for (const [key, value] of Object.entries(typeMap)) {
      if (lowerType.includes(key.toLowerCase())) {
        return value
      }
    }
    
    // Si no está en el mapa, retornar el tipo original
    return type
  }

  /**
   * Genera los INSERT statements para los datos
   */
  private static generateTableData(tableName: string, data: any[]): string {
    if (data.length === 0) return ''

    const columns = Object.keys(data[0])
    const columnList = columns.map(c => `"${c}"`).join(', ')
    
    // Generar inserts en bloques de 100 registros
    const chunks = this.chunkArray(data, 100)
    const insertStatements: string[] = []

    for (const chunk of chunks) {
      const values = chunk.map(row => {
        const vals = columns.map(col => this.formatValue(row[col]))
        return `(${vals.join(', ')})`
      }).join(',\n    ')

      insertStatements.push(
`INSERT INTO public."${tableName}" (${columnList})
VALUES
    ${values};`
      )
    }

    return `-- =====================================================
-- DATA: ${tableName} (${data.length} rows)
-- =====================================================

${insertStatements.join('\n\n')}`
  }

  /**
   * Formatea un valor para SQL
   */
  private static formatValue(value: any): string {
    if (value === null || value === undefined) {
      return 'NULL'
    }
    
    if (typeof value === 'boolean') {
      return value ? 'true' : 'false'
    }
    
    if (typeof value === 'number') {
      return value.toString()
    }
    
    if (Array.isArray(value)) {
      // Array de PostgreSQL
      if (value.length === 0) {
        return "ARRAY[]::text[]"
      }
      
      // Formatear cada elemento del array
      const formattedElements = value.map(item => {
        if (item === null || item === undefined) {
          return 'NULL'
        }
        // Escapar comillas simples en cada elemento
        return `'${item.toString().replace(/'/g, "''")}'`
      })
      
      return `ARRAY[${formattedElements.join(', ')}]::text[]`
    }
    
    if (typeof value === 'object') {
      // JSON objects (no arrays, ya los manejamos arriba)
      return `'${JSON.stringify(value).replace(/'/g, "''")}'::jsonb`
    }
    
    // String - escapar comillas simples
    return `'${value.toString().replace(/'/g, "''")}'`
  }

  /**
   * Genera los CREATE INDEX statements
   */
  private static generateIndexes(metadata: TableMetadata): string {
    if (metadata.indexes.length === 0) return ''

    const statements = metadata.indexes.map(idx => {
      const unique = idx.unique ? 'UNIQUE ' : ''
      const columns = idx.columns.map(c => `"${c}"`).join(', ')
      return `CREATE ${unique}INDEX "${idx.name}" ON public."${metadata.tableName}" USING ${idx.type} (${columns});`
    })

    return `-- =====================================================
-- INDEXES: ${metadata.tableName}
-- =====================================================

${statements.join('\n')}`
  }

  /**
   * Genera los ALTER TABLE para foreign keys
   */
  private static generateForeignKeys(metadata: TableMetadata): string {
    if (metadata.foreignKeys.length === 0) return ''

    const statements = metadata.foreignKeys.map(fk => {
      return `ALTER TABLE ONLY public."${metadata.tableName}"
    ADD CONSTRAINT "${fk.name}" FOREIGN KEY ("${fk.column}")
    REFERENCES public."${fk.referencedTable}"("${fk.referencedColumn}")
    ON UPDATE ${fk.onUpdate} ON DELETE ${fk.onDelete};`
    })

    return `-- =====================================================
-- FOREIGN KEYS: ${metadata.tableName}
-- =====================================================

${statements.join('\n\n')}`
  }

  /**
   * Genera las políticas RLS
   */
  private static generateRLSPolicies(policies: RLSPolicy[]): string {
    if (policies.length === 0) return ''

    const tableName = policies[0].tableName
    const statements: string[] = [
      `ALTER TABLE public."${tableName}" ENABLE ROW LEVEL SECURITY;`,
      ''
    ]

    for (const policy of policies) {
      let policySQL = `CREATE POLICY "${policy.policyName}" ON public."${tableName}"`
      policySQL += `\n    AS PERMISSIVE FOR ${policy.command}`
      policySQL += `\n    TO ${policy.roles.join(', ')}`
      
      if (policy.using) {
        policySQL += `\n    USING (${policy.using})`
      }
      
      if (policy.withCheck) {
        policySQL += `\n    WITH CHECK (${policy.withCheck})`
      }
      
      policySQL += ';'
      statements.push(policySQL)
    }

    return `-- =====================================================
-- RLS POLICIES: ${tableName}
-- =====================================================

${statements.join('\n\n')}`
  }

  /**
   * Divide un array en chunks
   */
  private static chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = []
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size))
    }
    return chunks
  }
}